<!DOCTYPE html>
<html lang="ru">

<head>
  <meta charset="UTF-8" />
  <title>Pixi Snake —Å –º–µ–Ω—é –ø–æ—Å–ª–µ –ø—Ä–æ–∏–≥—Ä—ã—à–∞</title>
  <link rel="icon" type="image/x-icon" href="favicon.ico">
  <style>
    html,
    body {
      margin: 0;
      height: 100%;
      background: #111;
      display: flex;
      justify-content: center;
      align-items: center;
      font-family: monospace, monospace;
      overflow: hidden;
      color: white;
    }

    canvas {
      box-shadow: 0 0 30px rgba(0, 255, 0, 0.2);
      image-rendering: pixelated;
    }

    #overlay {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.7);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      font-size: 24px;
      z-index: 10;
      user-select: none;
    }

    #overlay.hidden {
      display: none;
    }

    #overlay button {
      margin-top: 20px;
      padding: 10px 30px;
      font-size: 20px;
      cursor: pointer;
      border: none;
      border-radius: 8px;
      background: #0f0;
      color: #111;
      font-weight: bold;
      transition: background 0.3s;
    }

    #overlay button:hover {
      background: #0c0;
    }
  </style>
</head>

<body>
  <div id="overlay">
    <div id="message">üêç SNAKE PIXI</div>
    <button id="startBtn">–ò–≥—Ä–∞—Ç—å</button>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/pixi.js@7.2.4/dist/pixi.min.js"></script>
  <script>
    const CELL = 25;
    const GRID = 20;

    const app = new PIXI.Application({
      width: GRID * CELL,
      height: GRID * CELL,
      backgroundColor: 0x222222,
    });
    document.body.appendChild(app.view);

    const snakeGraphics = new PIXI.Container();
    const foodGraphics = new PIXI.Graphics();
    const uiContainer = new PIXI.Container();
    let tongueGraphics = new PIXI.Graphics();

    app.stage.addChild(snakeGraphics, foodGraphics, uiContainer);

    const overlay = document.getElementById('overlay');
    const message = document.getElementById('message');
    const startBtn = document.getElementById('startBtn');



    // UI —Ç–µ–∫—Å—Ç—ã
    const style = new PIXI.TextStyle({
      fill: "#00ff00",
      fontSize: 18,
      fontWeight: "bold",
      dropShadow: true,
      dropShadowColor: "#000000",
      dropShadowDistance: 2,
    });

    const scoreText = new PIXI.Text("–ú—è—Å–æ: 0", style);
    scoreText.position.set(10, 10);

    const timeText = new PIXI.Text("–í—Ä–µ–º—è: 00:00", style);
    timeText.position.set(10, 30);

    uiContainer.addChild(scoreText, timeText);

    let snake, direction, food, isMoving, score, gameInterval, speed, startTime, timerInterval;
    let foodHue = 0;
    let obstacles = [];
    let obstaclesSpawned = 0;

    let bestScore = {
      meat: 0,
      time: 0,
    };

    const bestText = new PIXI.Text("–õ—É—á—à–µ–µ: 0 –º—è—Å–æ / 00:00", style);
    bestText.position.set(10, 50);
    uiContainer.addChild(bestText);

    // –∑–∞–≥—Ä—É–∂–∞–µ–º –ª—É—á—à–∏–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç
    const saved = localStorage.getItem('snakeBestScore');
    if (saved) {
      bestScore = JSON.parse(saved);
      bestText.text = `–õ—É—á—à–µ–µ: ${bestScore.meat} –º—è—Å–æ / ${formatTime(bestScore.time)}`;
    }

    const controlsText = new PIXI.Text(
      "üïπ –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ:\n‚Üê ‚Üë ‚Üí ‚Üì ‚Äî –î–≤–∏–∂–µ–Ω–∏–µ\n–ü—Ä–æ–±–µ–ª ‚Äî –Ø–∑—ã–∫ (—Å—ä–µ–¥–∞–µ—Ç –±–ª–æ–∫)",
      {
        fontFamily: "monospace",
        fontSize: 14,
        fill: "#ccc",
      }
    );
    controlsText.position.set(app.screen.width - 230, 450);
    uiContainer.addChild(controlsText);

    app.stage.addChild(tongueGraphics);

    let tongueLength = 3;
    let tongueCooldown = false;

    function formatTime(ms) {
      const totalSeconds = Math.floor(ms / 1000);
      const minutes = String(Math.floor(totalSeconds / 60)).padStart(2, "0");
      const seconds = String(totalSeconds % 60).padStart(2, "0");
      return `${minutes}:${seconds}`;
    }

    function spawnFood() {
      while (true) {
        const fx = Math.floor(Math.random() * GRID);
        const fy = Math.floor(Math.random() * GRID);

        const onSnake = snake.some((s) => s.x === fx && s.y === fy);
        const onObstacle = obstacles.some((o) => o.x === fx && o.y === fy);

        if (!onSnake && !onObstacle) {
          food = { x: fx, y: fy };
          break;
        }
      }

      foodGraphics.clear();
      foodGraphics.beginFill(PIXI.utils.string2hex(hslToHex(foodHue, 100, 50)));
      foodGraphics.drawCircle(food.x * CELL + CELL / 2, food.y * CELL + CELL / 2, CELL * 0.3);
      foodGraphics.endFill();
    }

    function hslToHex(h, s, l) {
      s /= 100;
      l /= 100;
      let c = (1 - Math.abs(2 * l - 1)) * s,
        x = c * (1 - Math.abs(((h / 60) % 2) - 1)),
        m = l - c / 2,
        r = 0,
        g = 0,
        b = 0;
      if (0 <= h && h < 60) [r, g, b] = [c, x, 0];
      else if (60 <= h && h < 120) [r, g, b] = [x, c, 0];
      else if (120 <= h && h < 180) [r, g, b] = [0, c, x];
      else if (180 <= h && h < 240) [r, g, b] = [0, x, c];
      else if (240 <= h && h < 300) [r, g, b] = [x, 0, c];
      else if (300 <= h && h < 360) [r, g, b] = [c, 0, x];
      r = Math.round((r + m) * 255);
      g = Math.round((g + m) * 255);
      b = Math.round((b + m) * 255);
      return ((r << 16) + (g << 8) + b).toString(16).padStart(6, "0");
    }

    function getCellInFront() {
      const head = snake[0];
      let dx = 0, dy = 0;

      if (direction === "up") dy = -1;
      if (direction === "down") dy = 1;
      if (direction === "left") dx = -1;
      if (direction === "right") dx = 1;

      return {
        x: (head.x + dx + GRID) % GRID,
        y: (head.y + dy + GRID) % GRID,
      };
    }

    function spawnObstacle() {
      const dangerZone = getCellInFront();

      let attempts = 0;
      while (attempts < 100) {
        const ox = Math.floor(Math.random() * GRID);
        const oy = Math.floor(Math.random() * GRID);
        const occupied =
          snake.some(p => p.x === ox && p.y === oy) ||
          food.x === ox && food.y === oy ||
          obstacles.some(p => p.x === ox && p.y === oy) ||
          (ox === dangerZone.x && oy === dangerZone.y);

        if (!occupied) {
          obstacles.push({ x: ox, y: oy });
          break;
        }
        attempts++;
      }
    }

    function drawSnake() {
      snakeGraphics.removeChildren();

      // –û—Ç—Ä–∏—Å–æ–≤–∫–∞ –ø—Ä–µ–ø—è—Ç—Å—Ç–≤–∏–π
      for (let obs of obstacles) {
        const g = new PIXI.Graphics();
        g.beginFill(0xff0000);
        g.drawRect(0, 0, CELL, CELL);
        g.endFill();
        g.x = obs.x * CELL;
        g.y = obs.y * CELL;
        snakeGraphics.addChild(g);
      }

      // –û—Ç—Ä–∏—Å–æ–≤–∫–∞ –∑–º–µ–∏
      for (let i = 0; i < snake.length; i++) {
        const g = new PIXI.Graphics();
        const alpha = 1 - i * 0.1;
        g.beginFill(i === 0 ? 0xffff00 : 0x00ff00, alpha > 0.3 ? alpha : 0.3);
        g.drawCircle(CELL / 2, CELL / 2, (CELL - 4) / 2);
        g.endFill();
        g.x = snake[i].x * CELL;
        g.y = snake[i].y * CELL;
        snakeGraphics.addChild(g);
      }
    }

    function startGame() {
      snake = [{ x: 5, y: 5 }];
      direction = "right";
      score = 0;
      speed = 150;
      isMoving = false;
      startTime = Date.now();
      obstacles = [];
      obstaclesSpawned = 0;

      spawnFood();
      drawSnake();
      updateUI();

      overlay.classList.add('hidden');

      if (gameInterval) clearInterval(gameInterval);
      gameInterval = setInterval(move, speed);

      if (timerInterval) clearInterval(timerInterval);
      timerInterval = setInterval(() => {
        updateUI();
        animateFood();
      }, 50);
    }

    function updateUI() {
      scoreText.text = `–ú—è—Å–æ: ${score}`;
      const elapsed = Date.now() - startTime;
      timeText.text = `–í—Ä–µ–º—è: ${formatTime(elapsed)}`;
    }

    function animateFood() {
      foodHue += 2;
      if (foodHue >= 360) foodHue = 0;
      foodGraphics.clear();
      foodGraphics.beginFill(PIXI.utils.string2hex(hslToHex(foodHue, 100, 50)));
      foodGraphics.drawCircle(food.x * CELL + CELL / 2, food.y * CELL + CELL / 2, CELL * 0.3);
      foodGraphics.endFill();
    }

    function move() {
      const head = { ...snake[0] };
      if (direction === "up") head.y -= 1;
      if (direction === "down") head.y += 1;
      if (direction === "left") head.x -= 1;
      if (direction === "right") head.x += 1;

      head.x = (head.x + GRID) % GRID;
      head.y = (head.y + GRID) % GRID;

      if (snake.some((s) => s.x === head.x && s.y === head.y)) {
        gameOver();
        return;
      }

      snake.unshift(head);

      if (head.x === food.x && head.y === food.y) {
        score++;
        speed = Math.max(60, speed - 10);
        clearInterval(gameInterval);
        gameInterval = setInterval(move, speed);
        spawnFood();
      } else {
        snake.pop();
      }

      drawSnake();
      isMoving = true;
      updateUI();

      if (score > 10 && obstaclesSpawned < (score - 10)) {
        spawnObstacle();
        obstaclesSpawned++;
      }

      if (obstacles.some(p => p.x === head.x && p.y === head.y)) {
        gameOver();
        return;
      }
    }

    function shootTongue() {
      if (tongueCooldown) return;
      tongueCooldown = true;

      const head = snake[0];
      let dx = 0, dy = 0;

      if (direction === "up") dy = -1;
      if (direction === "down") dy = 1;
      if (direction === "left") dx = -1;
      if (direction === "right") dx = 1;

      tongueGraphics.clear();
      tongueGraphics.beginFill(0xff66cc);

      for (let i = 1; i <= tongueLength; i++) {
        const tx = (head.x + dx * i + GRID) % GRID;
        const ty = (head.y + dy * i + GRID) % GRID;

        // –ù–∞—Ä–∏—Å—É–µ–º "—è–∑—ã–∫"
        tongueGraphics.drawRect(tx * CELL + CELL / 4, ty * CELL + CELL / 4, CELL / 2, CELL / 2);

        // –ü—Ä–æ–≤–µ—Ä–∏–º, –µ—Å—Ç—å –ª–∏ –ø—Ä–µ–ø—è—Ç—Å—Ç–≤–∏–µ
        const hitIndex = obstacles.findIndex(o => o.x === tx && o.y === ty);
        if (hitIndex !== -1) {
          // –°—ä–µ–¥–∞–µ–º –ø—Ä–µ–ø—è—Ç—Å—Ç–≤–∏–µ
          obstacles.splice(hitIndex, 1);
        }
      }

      tongueGraphics.endFill();
      drawSnake(); // –ø–µ—Ä–µ—Ä–∏—Å—É–µ–º –±–µ–∑ —É–¥–∞–ª—ë–Ω–Ω—ã—Ö –ø—Ä–µ–ø—è—Ç—Å—Ç–≤–∏–π

      setTimeout(() => {
        tongueGraphics.clear();
        tongueCooldown = false;
      }, 200); // —è–∑—ã–∫ –∏—Å—á–µ–∑–∞–µ—Ç —á–µ—Ä–µ–∑ 200 –º—Å
    }

    function gameOver() {
      updateBestResult();
      clearInterval(gameInterval);
      clearInterval(timerInterval);
      message.innerHTML = `
        üíÄ GAME OVER<br>
        –ú—è—Å–æ: ${score}<br>
        –í—Ä–µ–º—è: ${timeText.text.split(' ')[1]}
      `;
      startBtn.textContent = "–ò–≥—Ä–∞—Ç—å –∑–∞–Ω–æ–≤–æ";
      overlay.classList.remove('hidden');
    }

    function updateBestResult() {
      const elapsed = Date.now() - startTime;

      if (
        score > bestScore.meat ||
        (score === bestScore.meat && elapsed < bestScore.time)
      ) {
        bestScore = {
          meat: score,
          time: elapsed,
        };
        localStorage.setItem('snakeBestScore', JSON.stringify(bestScore));
      }

      bestText.text = `–õ—É—á—à–µ–µ: ${bestScore.meat} –º—è—Å–æ / ${formatTime(bestScore.time)}`;
    }

    window.addEventListener("keydown", (e) => {
      if (!isMoving) return;
      if (e.key === "ArrowUp" && direction !== "down") direction = "up";
      if (e.key === "ArrowDown" && direction !== "up") direction = "down";
      if (e.key === "ArrowLeft" && direction !== "right") direction = "left";
      if (e.key === "ArrowRight" && direction !== "left") direction = "right";
      isMoving = false;
      if (e.code === "Space") {
        shootTongue();
      }
    });

    // –ó–∞–ø—É—Å–∫–∞—Ç—å –∏–≥—Ä—É –ø–æ—Å–ª–µ –Ω–∞–∂–∞—Ç–∏—è –∫–Ω–æ–ø–∫–∏
    startBtn.addEventListener("click", startGame);

    // –°–Ω–∞—á–∞–ª–∞ –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –º–µ–Ω—é
    overlay.classList.remove('hidden');
  </script>
</body>

</html>